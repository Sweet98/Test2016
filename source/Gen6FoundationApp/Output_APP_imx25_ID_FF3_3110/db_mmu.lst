


ARM Macro Assembler    Page 1 


    1 00000000         ;;
    2 00000000         ; MX1 Dragonball defines for MMU/Cache setup
    3 00000000         ; Date: 3/08/02
    4 00000000         ; Target: Matrix MX1 Development board
    5 00000000         ; Tools: ARM SDT 2.5 for now... will be ADS 1.1 or GNU
    6 00000000         ;;
    7 00000000         ;;======================================================
                       ================================
    8 00000000         ;; Revision information
    9 00000000         ;;======================================================
                       ================================
   10 00000000         ;; $RCSfile: db_shared/db_mmu.s $
   11 00000000         ;; $Revision: 1.25.2.18 $
   12 00000000         ;; $Date: 2009/10/08 13:28:29EDT $
   13 00000000         ;;======================================================
                       ================================
   14 00000000         ;
   15 00000000         ; Starting point was Digital defines from the days of th
                       e StrongArm (Now Intel's,
   16 00000000         ; but originally a Digital part)... code was changed for
                        our hardware and the differences in the
   17 00000000         ; MX1 versus SA.
   18 00000000         ;
   19 00000000         ;; this code is intended to provide all the necessary ro
                       utines for
   20 00000000         ;; enabling MMU, Icache and Dcache for this hardware.
   21 00000000         ; Op_code will only be stored in Flash... will be run ou
                       t of RAM @ C0000000.
   22 00000000         ;
   23 00000000         ; So, intent of MMU setup is:
   24 00000000         ; 1.  1<->1 mapping of VA and PA address space
   25 00000000         ;  2.  1MB sections for 4MB of DRAM
   26 00000000         ; 3.  64KB pages for Flash  -- might not do because no c
                       ode or data will be here
   27 00000000         ; 4.  Cacheable and bufferable access to DRAM
   28 00000000         ; 5.  RO user access to Flash
   29 00000000         ;  6.  Invalid accesses (aborts) configured for unsuppor
                       ted mem space
   30 00000000         ;  7.  Noncacheable and nonburferable I/O -- and -- Inte
                       rnal Reg space
   31 00000000         ;
   32 00000000         
   33 00000000                 INCLUDE          mmumacro.s
    1 00000000         ;;
    2 00000000         ; MX1 Dragonball defines for MMU/Cache setup
    3 00000000         ; Date: 2/22/02
    4 00000000         ; Target: Matrix MX1 Development board
    5 00000000         ; Tools: ARM SDT 2.5 for now... will be ADS 1.1 or GNU
    6 00000000         ;
    7 00000000         ; Starting point was Digital defines from the days of th
                       e StrongArm (Now Intel's,
    8 00000000         ; but originally a Digital part)... code was changed for
                        our hardware and the differences in the
    9 00000000         ; MX1 versus SA.
   10 00000000         ;;
   11 00000000         ;;======================================================
                       ================================
   12 00000000         ;; Revision information
   13 00000000         ;;======================================================



ARM Macro Assembler    Page 2 


                       ================================
   14 00000000         ;; $RCSfile: db_shared/mmumacro.s $
   15 00000000         ;; $Revision: 1.2 $
   16 00000000         ;; $Date: 2004/04/20 08:18:56EDT $
   17 00000000         ;;======================================================
                       ================================
   18 00000000         ;/******************************************************
                       ***********************
   19 00000000         
   20 00000000         ;       Copyright © 1995, 1996 Digital Equipment Corpora
                       tion,
   21 00000000         ;                       Maynard, Massachusetts.
   22 00000000         
   23 00000000         ;                        All Rights Reserved
   24 00000000         
   25 00000000         ;Permission to use, copy, modify, and distribute this so
                       ftware and its
   26 00000000         ;documentation for any purpose and without fee is hereby
                        granted, provided
   27 00000000         ;that the copyright notice and this permission notice ap
                       pear in all copies
   28 00000000         ;of software and supporting documentation, and that the 
                       name of Digital not
   29 00000000         ;be used in advertising or publicity pertaining to distr
                       ibution of the software
   30 00000000         ;without specific, written prior permission. Digital gra
                       nts this permission
   31 00000000         ;provided that you prominently mark, as not part of the 
                       original, any
   32 00000000         ;modifications made to this software or documentation.
   33 00000000         
   34 00000000         ;Digital Equipment Corporation disclaims all warranties 
                       and/or guarantees
   35 00000000         ;with regard to this software, including all implied war
                       ranties of fitness for
   36 00000000         ;a particular purpose and merchantability, and makes no 
                       representations
   37 00000000         ;regarding the use of, or the results of the use of, the
                        software and
   38 00000000         ;documentation in terms of correctness, accuracy, reliab
                       ility, currentness or
   39 00000000         ;otherwise; and you rely on the software, documentation 
                       and results solely at
   40 00000000         ;your own risk.
   41 00000000         
   42 00000000         ;*******************************************************
                       ***********************
   43 00000000         
   44 00000000         ; Macros for SA-110 Coprocessor Access
   45 00000000         
   46 00000000         ;       $Id: db_shared/mmumacro.s 1.2 2004/04/20 08:18:5
                       6EDT keysb Exp  $
   47 00000000         
   48 00000000         ;*******************************************************
                       ***********************/
   49 00000000         
   50 00000000         
   51 00000000                 INCLUDE          mmu_h.s
    1 00000000         ;;



ARM Macro Assembler    Page 3 


    2 00000000         ; MX1 Dragonball defines for MMU/Cache setup
    3 00000000         ; Date: 2/22/02
    4 00000000         ; Target: Matrix MX1 Development board
    5 00000000         ; Tools: ARM SDT 2.5 for now... will be ADS 1.1 or GNU
    6 00000000         ;
    7 00000000         ; Starting point was Digital defines from the days of th
                       e StrongArm (Now Intel's,
    8 00000000         ; but originally a Digital part)... code was changed for
                        our hardware and the differences in the
    9 00000000         ; MX1 versus SA.
   10 00000000         ;;
   11 00000000         ;;======================================================
                       ================================
   12 00000000         ;; Revision information
   13 00000000         ;;======================================================
                       ================================
   14 00000000         ;; $RCSfile: db_shared/mmu_h.s $
   15 00000000         ;; $Revision: 1.10.1.5 $
   16 00000000         ;; $Date: 2009/05/27 17:20:24EDT $
   17 00000000         ;;======================================================
                       ================================
   18 00000000         ;/* ****************************************************
                       ************************
   19 00000000         ;
   20 00000000         ;       Copyright © 1995, 1996 Digital Equipment Corpora
                       tion,
   21 00000000         ;                       Maynard, Massachusetts.
   22 00000000         ;
   23 00000000         ;                       All Rights Reserved
   24 00000000         ;
   25 00000000         ;Permission to use, copy, modify, and distribute this so
                       ftware and its
   26 00000000         ;documentation for any purpose and without fee is hereby
                        granted, provided
   27 00000000         ;that the copyright notice and this permission notice ap
                       pear in all copies
   28 00000000         ;of software and supporting documentation, and that the 
                       name of Digital not
   29 00000000         ;be used in advertising or publicity pertaining to distr
                       ibution of the
   30 00000000         ;software without specific, written prior permission. Di
                       gital grants this
   31 00000000         ;permission provided that you prominently mark, as not p
                       art of the original,
   32 00000000         ;any modifications made to this software or documentatio
                       n.
   33 00000000         ;
   34 00000000         ;Digital Equipment Corporation disclaims all warranties 
                       and/or guarantees
   35 00000000         ;with regard to this software, including all implied war
                       ranties of fitness
   36 00000000         ;for a particular purpose and merchantability, and makes
                        no representations
   37 00000000         ;regarding the use of, or the results of the use of, the
                        software and
   38 00000000         ;documentation in terms of correctness, accuracy, reliab
                       ility, currentness
   39 00000000         ;or otherwise; and you rely on the software, documentati
                       on and results



ARM Macro Assembler    Page 4 


   40 00000000         ;solely at your own risk.
   41 00000000         ;
   42 00000000         ;*******************************************************
                       *********************
   43 00000000         ;
   44 00000000         ;  SA-110 MMU specifics - constants, registers etc.
   45 00000000         ;
   46 00000000         ;
   47 00000000         ;*******************************************************
                       ********************/
   48 00000000         
   49 00000000         
   50 00000000 00004000 
                       DCACHE_SIZE
                               EQU              0X4000      ; MX1 has a 16KB Dc
                                                            ache
   51 00000000 00000020 
                       DCACHE_LINE
                               EQU              0X20        ; 32B cache line en
                                                            try
   52 00000000 00001000 
                       L1_TABLE_ENTRIES
                               EQU              0x1000      ; 16kB table (word 
                                                            entries)
   53 00000000 00000100 
                       L2_TABLE_ENTRIES
                               EQU              0x100       ;  1kB table (word 
                                                            entries)
   54 00000000 00000001 
                       L2_CONTROL
                               EQU              0x1         ; domain0, page tab
                                                            le pointer
   55 00000000         
   56 00000000         
   57 00000000         ; Definitions used in conditional assembly of Icache, Dc
                       ache and Write Buffer
   58 00000000         ; options
   59 00000000         
   60 00000000 00001000 
                       IC_ON   EQU              0x1000
   61 00000000 00000000 
                       IC_OFF  EQU              0x0
   62 00000000         
   63 00000000 00000004 
                       DC_ON   EQU              0x4
   64 00000000 00000000 
                       DC_OFF  EQU              0x0
   65 00000000         
   66 00000000 00000008 
                       WB_ON   EQU              0x8
   67 00000000 00000000 
                       WB_OFF  EQU              0x0
   68 00000000         
   69 00000000         
   70 00000000         ; Bit definitions for the control register:
   71 00000000         
   72 00000000         ; enables are logically OR'd with the control register
   73 00000000         ; use bit clears (BIC's) to disable functions
   74 00000000         ; *** all bits cleared on RESET ***



ARM Macro Assembler    Page 5 


   75 00000000         
   76 00000000 00000001 
                       EnableMMU
                               EQU              0x1
   77 00000000 00000002 
                       EnableAlignFault
                               EQU              0x2
   78 00000000 00000004 
                       EnableDcache
                               EQU              0x4         ;0x4
   79 00000000 00000008 
                       EnableWB
                               EQU              0x8
   80 00000000 00000080 
                       EnableBigEndian
                               EQU              0x80
   81 00000000 00000100 
                       EnableMMU_S
                               EQU              0x100       ; selects MMU acces
                                                            s checks
   82 00000000 00000200 
                       EnableMMU_R
                               EQU              0x200       ; selects MMU acces
                                                            s checks
   83 00000000 00001000 
                       EnableIcache
                               EQU              0x1000
   84 00000000 00004000 
                       EnableMMU_RR
                               EQU              0x4000
   85 00000000         
   86 00000000                 END
   52 00000000         
   53 00000000         
   54 00000000         ; SA-110 *only* supports Coprocessor number 15
   55 00000000         ; Only MCR and MRC coprocessor instructions are supporte
                       d - the others
   56 00000000         ; ...generate an UNDEFINED exception
   57 00000000         ;
   58 00000000         ; CP15 registers are architected as per the ARM V4 archi
                       tecture spec
   59 00000000         ;
   60 00000000         ; Register0 ID register                   READ_ONLY
   61 00000000         ;       Register1       Control                       RE
                       AD_WRITE
   62 00000000         ;       Register2       Translation Table Base        RE
                       AD_WRITE
   63 00000000         ;       Register3       Domain Access Control         RE
                       AD_WRITE
   64 00000000         ;       Register4       Reserved
   65 00000000         ;       Register5       Fault Status                  RE
                       AD_WRITE
   66 00000000         ;       Register6       Fault Address                 RE
                       AD_WRITE
   67 00000000         ;       Register7       Cache Operations              WR
                       ITE_ONLY
   68 00000000         ;       Register8       TLB Operations                WR
                       ITE_ONLY
   69 00000000         ;       Register9-14    Reserved



ARM Macro Assembler    Page 6 


   70 00000000         ;       Register15      SA-110 specific tst/clk/idle  WR
                       ITE_ONLY
   71 00000000         
   72 00000000         ;; Defined Macros:
   73 00000000         ;;
   74 00000000         ;RDCP15_ID     Rx read of ID register
   75 00000000         ;RDCP15_Control    Rx   read of Control register
   76 00000000         ;WRCP15_Control    Rx write of Control register
   77 00000000         ;RDCP15_TTBase     Rx read of Translation Table Base reg
                       .
   78 00000000         ;WRCP15_TTBase     Rx write of Translation Table Base re
                       g.
   79 00000000         ;RDCP15_DAControl  Rx read of Domain Access Control reg.
                       
   80 00000000         ;WRCP15_DAControl  Rx write of Domain Access Control reg
                       .
   81 00000000         ;RDCP15_FaultStatus  Rx read of Fault Status register
   82 00000000         ;WRCP15_FaultStatus      Rx write of Fault Status regist
                       er
   83 00000000         ;RDCP15_FaultAddress     Rx read Fault Address register
   84 00000000         ;WRCP15_FaultAddress   Rx write of Fault Address registe
                       r
   85 00000000         ;WRCP15_FlushIC_DC   Rx cache control   Flush ICache + D
                       Cache
   86 00000000         ;;            Rx redundant but rqud for MACRO
   87 00000000         ;WRCP15_FlushIC    Rx cache control   Flush ICache
   88 00000000         ;;            Rx redundant but rqud for MACRO
   89 00000000         ;WRCP15_FlushDC    Rx cache control   Flush DCache
   90 00000000         ;;            Rx redundant but rqud for MACRO
   91 00000000         ;WRCP15_CacheFlushDentry Rx cache control   Flush DCache
                        entry
   92 00000000         ;;            Rx source for VA
   93 00000000         ;WRCP15_CleanDCentry   Rx   cache control   Clean DCache
                        entry
   94 00000000         ;;            Rx source for VA
   95 00000000         ;WRCP15_Clean_FlushDCentry Rx   cache control   Clean + 
                       Flush DCache entry
   96 00000000         ;;            Rx source for VA
   97 00000000         ;WRCP15_DrainWriteBuffer Rx Drain Write Buffer
   98 00000000         ;;            Rx redundant but rqud for MACRO
   99 00000000         ;WRCP15_FlushITB_DTB   Rx TLB control     Flush ITB's + 
                       DTB's
  100 00000000         ;;            Rx redundant but rqud for MACRO
  101 00000000         ;WRCP15_FlushITB   Rx TLB control     Flush ITB's
  102 00000000         ;;            Rx redundant but rqud for MACRO
  103 00000000         ;WRCP15_FlushDTB   Rx TLB control     Flush DTB's
  104 00000000         ;;            Rx redundant but rqud for MACRO
  105 00000000         ;WRCP15_FlushDTBentry    Rx TLB control     Flush DTB en
                       try
  106 00000000         ;;            Rx source for VA
  107 00000000         ;WRCP15_EnableClockSW  Rx test/clock/idle control -Enabl
                       e Clock Switching
  108 00000000         ;;            Rx redundant but rqud for MACRO
  109 00000000         ;WRCP15_DisableClockSW   Rx test/clock/idle control -Dis
                       able Clock Switching
  110 00000000         ;;            Rx redundant but rqud for MACRO
  111 00000000         ;WRCP15_DisablenMCLK   Rx test/clock/idle control -Disab
                       le nMCLK output
  112 00000000         ;;            Rx redundant but rqud for MACRO



ARM Macro Assembler    Page 7 


  113 00000000         ;WRCP15_WaitInt    Rx test/clock/idle control -Wait for 
                       Interrupt
  114 00000000         ;;            Rx redundant but rqud for MACRO
  115 00000000         
  116 00000000         ;Coprocessor read of ID register
  117 00000000         ;
  118 00000000                 MACRO
  119 00000000                 RDCP15_ID        $reg_number
  120 00000000                 MRC              p15, 0, $reg_number, c0, c0 ,0
  121 00000000                 MEND
  122 00000000         
  123 00000000         ;Coprocessor read of Control register
  124 00000000         ;
  125 00000000                 MACRO
  126 00000000                 RDCP15_Control   $reg_number
  127 00000000                 MRC              p15, 0, $reg_number, c1, c0 ,0
  128 00000000         
  129 00000000                 MEND
  130 00000000         
  131 00000000         ;Coprocessor write of Control register
  132 00000000         ;
  133 00000000                 MACRO
  134 00000000                 WRCP15_Control   $reg_number
  135 00000000                 MCR              p15, 0, $reg_number, c1, c0 ,0
  136 00000000         
  137 00000000                 MEND
  138 00000000         
  139 00000000         ;Coprocessor read of Translation Table Base reg.
  140 00000000         ;
  141 00000000                 MACRO
  142 00000000                 RDCP15_TTBase    $reg_number
  143 00000000                 MRC              p15, 0, $reg_number, c2, c0 ,0
  144 00000000         
  145 00000000                 MEND
  146 00000000         
  147 00000000         ;Coprocessor write of Translation Table Base reg.
  148 00000000         ;
  149 00000000                 MACRO
  150 00000000                 WRCP15_TTBase    $reg_number
  151 00000000                 MCR              p15, 0, $reg_number , c2, c0 ,0
  152 00000000         
  153 00000000                 MEND
  154 00000000         
  155 00000000         ;Coprocessor read of Domain Access Control reg.
  156 00000000         ;
  157 00000000                 MACRO
  158 00000000                 RDCP15_DAControl $reg_number
  159 00000000                 MRC              p15, 0, $reg_number, c3, c0 ,0
  160 00000000         
  161 00000000                 MEND
  162 00000000         
  163 00000000         ;Coprocessor write of Domain Access Control reg.
  164 00000000         ;
  165 00000000                 MACRO
  166 00000000                 WRCP15_DAControl $reg_number
  167 00000000                 MCR              p15, 0, $reg_number, c3, c0 ,0
  168 00000000         
  169 00000000                 MEND
  170 00000000         



ARM Macro Assembler    Page 8 


  171 00000000         ;Coprocessor read of Fault Status register
  172 00000000         ;
  173 00000000                 MACRO
  174 00000000                 RDCP15_FaultStatus
                                                $reg_number
  175 00000000                 MRC              p15, 0, $reg_number, c5, c0 ,0
  176 00000000         
  177 00000000                 MEND
  178 00000000         
  179 00000000         ;Coprocessor write of Fault Status register
  180 00000000         ;
  181 00000000                 MACRO
  182 00000000                 WRCP15_FaultStatus
                                                $reg_number
  183 00000000                 MCR              p15, 0, $reg_number, c5, c0 ,0
  184 00000000         
  185 00000000                 MEND
  186 00000000         
  187 00000000         ;Coprocessor read of Fault Address register
  188 00000000         ;
  189 00000000                 MACRO
  190 00000000                 RDCP15_FaultAddress
                                                $reg_number
  191 00000000                 MRC              p15, 0, $reg_number, c6, c0 ,0
  192 00000000         
  193 00000000                 MEND
  194 00000000         
  195 00000000         ;Coprocessor write of Fault Address register
  196 00000000         ;
  197 00000000                 MACRO
  198 00000000                 WRCP15_FaultAddress
                                                $reg_number
  199 00000000                 MCR              p15, 0, $reg_number, c6, c0 ,0
  200 00000000         
  201 00000000                 MEND
  202 00000000         
  203 00000000         ;Coprocessor cache control
  204 00000000         ;Flush ICache + DCache
  205 00000000         ;
  206 00000000                 MACRO
  207 00000000                 WRCP15_FlushIC_DC
                                                $reg_number
  208 00000000                 MCR              p15, 0, $reg_number, c7, c7 ,0
  209 00000000         
  210 00000000                 MEND
  211 00000000         
  212 00000000         ;Coprocessor cache control
  213 00000000         ;Flush ICache
  214 00000000         ;
  215 00000000                 MACRO
  216 00000000                 WRCP15_FlushIC   $reg_number
  217 00000000                 MCR              p15, 0, $reg_number, c7, c5 ,0
  218 00000000         
  219 00000000                 MEND
  220 00000000         
  221 00000000         ;Coprocessor cache control
  222 00000000         ;Flush DCache
  223 00000000         ;
  224 00000000                 MACRO



ARM Macro Assembler    Page 9 


  225 00000000                 WRCP15_FlushDC   $reg_number
  226 00000000                 MCR              p15, 0, $reg_number, c7, c6 ,0
  227 00000000         
  228 00000000                 MEND
  229 00000000         
  230 00000000         ;Coprocessor cache control
  231 00000000         ;Flush DCache entry
  232 00000000         ;
  233 00000000                 MACRO
  234 00000000                 WRCP15_CacheFlushDentry
                                                $reg_number
  235 00000000                 MCR              p15, 0, $reg_number, c7, c6 ,1
  236 00000000         
  237 00000000                 MEND
  238 00000000         
  239 00000000         ;Coprocessor cache control
  240 00000000         ;Clean DCache entry
  241 00000000         ;
  242 00000000                 MACRO
  243 00000000                 WRCP15_CleanDCentry
                                                $reg_number
  244 00000000                 MCR              p15, 0, $reg_number, c7, c10 ,1
  245 00000000         
  246 00000000                 MEND
  247 00000000         
  248 00000000         ;Coprocessor cache control
  249 00000000         ;Clean + Flush DCache entry
  250 00000000         ;
  251 00000000                 MACRO
  252 00000000                 WRCP15_Clean_FlushDCentry
                                                $reg_number
  253 00000000                 MCR              p15, 0, $reg_number, c7, c14 ,1
  254 00000000         
  255 00000000                 MEND
  256 00000000         
  257 00000000         ;Coprocessor Drain Write Buffer
  258 00000000         ;
  259 00000000                 MACRO
  260 00000000                 WRCP15_DrainWriteBuffer
                                                $reg_number
  261 00000000                 MCR              p15, 0, $reg_number, c7, c10 ,4
  262 00000000         
  263 00000000                 MEND
  264 00000000         
  265 00000000         
  266 00000000         ;Coprocessor TLB control
  267 00000000         ;Flush ITB + DTB
  268 00000000         ;
  269 00000000                 MACRO
  270 00000000                 WRCP15_FlushITB_DTB
                                                $reg_number
  271 00000000                 MCR              p15, 0, $reg_number, c8, c7 ,0
  272 00000000         
  273 00000000                 MEND
  274 00000000         
  275 00000000         ;Coprocessor TLB control
  276 00000000         ;Flush ITB
  277 00000000         ;
  278 00000000                 MACRO



ARM Macro Assembler    Page 10 


  279 00000000                 WRCP15_FlushITB  $reg_number
  280 00000000                 MCR              p15, 0, $reg_number, c8, c5 ,0
  281 00000000         
  282 00000000                 MEND
  283 00000000         
  284 00000000         ;Coprocessor TLB control
  285 00000000         ;Flush DTB
  286 00000000         ;
  287 00000000                 MACRO
  288 00000000                 WRCP15_FlushDTB  $reg_number
  289 00000000                 MCR              p15, 0, $reg_number, c8, c6 ,0
  290 00000000         
  291 00000000                 MEND
  292 00000000         
  293 00000000         ;Coprocessor TLB control
  294 00000000         ;Flush DTB entry
  295 00000000         
  296 00000000                 MACRO
  297 00000000                 WRCP15_FlushDTBentry
                                                $reg_number
  298 00000000                 MCR              p15, 0, $reg_number, c8, c6 ,1
  299 00000000         
  300 00000000                 MEND
  301 00000000         
  302 00000000         ;Coprocessor test/clock/idle control
  303 00000000         ;Enable Clock Switching
  304 00000000         ;
  305 00000000                 MACRO
  306 00000000                 WRCP15_EnableClockSW
                                                $reg_number
  307 00000000                 MCR              p15, 0, $reg_number, c15, c1 ,2
  308 00000000         
  309 00000000                 MEND
  310 00000000         
  311 00000000         ;Coprocessor test/clock/idle control
  312 00000000         ;Disable Clock Switching
  313 00000000         ;
  314 00000000                 MACRO
  315 00000000                 WRCP15_DisableClockSW
                                                $reg_number
  316 00000000                 MCR              p15, 0, $reg_number, c15, c2 ,2
  317 00000000         
  318 00000000                 MEND
  319 00000000         
  320 00000000         ;Coprocessor test/clock/idle control
  321 00000000         ;Disable nMCLK output
  322 00000000         ;
  323 00000000                 MACRO
  324 00000000                 WRCP15_DisablenMCLK
                                                $reg_number
  325 00000000                 MCR              p15, 0, $reg_number, c15, c4 ,2
  326 00000000         
  327 00000000                 MEND
  328 00000000         
  329 00000000         ;Coprocessor test/clock/idle control  ;; this is correct
                        for ARM920T.
  330 00000000         ;Wait for Interrupt
  331 00000000         ;
  332 00000000                 MACRO



ARM Macro Assembler    Page 11 


  333 00000000                 WRCP15_WaitInt   $reg_number
  334 00000000                 MCR              p15, 0, $reg_number, c7, c0 ,4
  335 00000000         
  336 00000000                 MEND
  337 00000000         
  338 00000000         
  339 00000000         
  340 00000000         
  341 00000000         ;
  342 00000000         ; MMUMACRO_CleanAndInvalidate
  343 00000000         ;  Clean and invalidate DCACHE and drain write buffer to
                        clear all
  344 00000000         ;  DCACHE hits and buffered writes.
  345 00000000         ;
  346 00000000                 MACRO
  347 00000000                 MMUMACRO_CleanAndInvalidate
                                                $reg1, $reg2, $reg3
  348 00000000         
  349 00000000                 RDCP15_Control   $reg1
  350 00000000                 ands             $reg1,$reg1,#EnableMMU
  351 00000000                 beq              MMUMACRO_CleanAndInvalidateBoth
Caches_Finish
  352 00000000         
  353 00000000                 mov              $reg3, #(8 - 1) << 5 
                                                            ; 8 segments
  354 00000000         l_seg
  355 00000000                 orr              $reg2, $reg3, #(64 - 1) << 26 
                                                            ; 64 entries
  356 00000000         l_ent
  357 00000000                 mcr              p15, 0, $reg2, c7, c14, 2 ; cle
                                                            an+invalidate D ind
                                                            ex
  358 00000000                 subs             $reg2, $reg2, #1 << 26
  359 00000000                 bcs              l_ent       ; entries 63 to 0
  360 00000000                 subs             $reg3, $reg3, #1 << 5
  361 00000000                 bcs              l_seg       ; segments 7 to 0
  362 00000000         
  363 00000000                 mov              $reg2, #0
  364 00000000                 mcr              p15, 0, $reg2, c7, c5, 0 ; inva
                                                            lidate I cache
  365 00000000                 mcr              p15, 0, $reg2, c7, c10, 4 
                                                            ; drain WB
  366 00000000         
  367 00000000         MMUMACRO_CleanAndInvalidate_Finish
  368 00000000         
  369 00000000                 MEND
  370 00000000         
  371 00000000         
  372 00000000         
  373 00000000         
  374 00000000         ;
  375 00000000         ; MMUMACRO_CleanAndInvalidateBothCaches
  376 00000000         ;  Clean and invalidate DCACHE, drain write buffer, and 
                       invalidate ICACHE to clear all
  377 00000000         ;  cache hits and buffered writes.  This macro is reloca
                       table, as all constants are
  378 00000000         ;  embedded in the code.
  379 00000000         ;
  380 00000000                 MACRO



ARM Macro Assembler    Page 12 


  381 00000000                 MMUMACRO_CleanAndInvalidateBothCaches
                                                $reg1, $reg2, $reg3
  382 00000000         
  383 00000000                 RDCP15_Control   $reg1
  384 00000000                 ands             $reg1,$reg1,#EnableMMU
  385 00000000                 beq              MMUMACRO_CleanAndInvalidateBoth
Caches_Finish
  386 00000000         
  387 00000000                 mov              $reg1, #7
  388 00000000         MMUMACRO_CleanAndInvalidateBothCaches_SegmentLoop
  389 00000000                 mov              $reg2, #63
  390 00000000         MMUMACRO_CleanAndInvalidateBothCaches_IndexLoop
  391 00000000                 mov              $reg3,$reg2, lsl #26
  392 00000000                 orr              $reg3,$reg3,$reg1, lsl #5
  393 00000000         
  394 00000000                 mcr              p15, 0, $reg3, c7, c14, 2 ;// C
                                                            lean and Invalidate
                                                             D Cache line
  395 00000000         
  396 00000000                 subs             $reg2,$reg2,#1
  397 00000000                 bpl              MMUMACRO_CleanAndInvalidateBoth
Caches_IndexLoop
  398 00000000         
  399 00000000         
  400 00000000                 subs             $reg1,$reg1,#1
  401 00000000                 bpl              MMUMACRO_CleanAndInvalidateBoth
Caches_SegmentLoop
  402 00000000         
  403 00000000         
  404 00000000                 mcr              p15, 0, $reg2, c7, c10, 4 ;// D
                                                            rain the write buff
                                                            er
  405 00000000         
  406 00000000                 mcr              p15, 0, $reg2, c7, c5, 0 ; inva
                                                            lidate I cache
  407 00000000         
  408 00000000         MMUMACRO_CleanAndInvalidateBothCaches_Finish
  409 00000000         
  410 00000000                 MEND
  411 00000000         
  412 00000000         
  413 00000000         
  414 00000000         
  415 00000000                 END
   34 00000000                 INCLUDE          db_memap.s
    1 00000000         ;/******************************************************
                       ******************/
    2 00000000         ;//
    3 00000000         ;// HHP 4480 embedded firmware
    4 00000000         ;// Memory map
    5 00000000         ;//  Date:       2/21/02
    6 00000000         ;//  Tools:      ARM SDT 2.5 for starters... will be ARM
                        ADS 1.1 or Metaware
    7 00000000         ;//  Target:     Dragon Ball MX1 based 4480
    8 00000000         ;;
    9 00000000         ;;======================================================
                       ================================
   10 00000000         ;; Revision information
   11 00000000         ;;======================================================



ARM Macro Assembler    Page 13 


                       ================================
   12 00000000         ;; $RCSfile: db_shared/db_memap.s $
   13 00000000         ;; $Revision: 1.21.2.10 $
   14 00000000         ;; $Date: 2009/10/06 17:11:17EDT $
   15 00000000         ;;======================================================
                       ================================
   16 00000000         ;*******************************************************
                       *****************
   17 00000000         ;*******************************************************
                       *****************
   18 00000000         
   19 00000000         
   20 00000000         ;; Flash fixed addresses (1MB)
   21 00000000         ;;
   22 00000000         ;; 0x00000000 to 0x00003FFF Boot code
   23 00000000         ;; 0x00004000 to 0x00005FFF Backup (User Defaults) Confi
                       guration data
   24 00000000         ;; 0x00006000 to 0x00007FFF Configuration data
   25 00000000         ;; 0x00008000 to 0x0000FFFF Manufacturing configuration 
                       area
   26 00000000         ;; 0x00010000 to 0x000EFFFF Operational code
   27 00000000         ;; 0x000F0000 to 0x000FFFF7 Reserved
   28 00000000         ;; 0x000FFFF8 to 0x000FFFFB Operational code size
   29 00000000         ;; 0x000FFFFC to 0x000FFFFF Operational code CRC
   30 00000000         
   31 00000000         
   32 00000000         ;; RAM fixed addresses (16 MB)
   33 00000000         ;;
   34 00000000         ;;    0x08000000 Op code code then data then heap
   35 00000000         ;;    various stacks run from top down
   36 00000000         ;;    0x08ffffff top of RAM
   37 00000000         
   38 00000000         
   39 00000000         ;; DDR SDRAM fixed addresses (128 MB)
   40 00000000         ;;
   41 00000000         ;;    0xA0000000 Op code code then data then heap for iM
                       X27
   42 00000000         ;;    various stacks run from top down
   43 00000000         ;;    0xA7FFFFFF top of RAM 
   44 00000000         
   45 00000000         ;; DDR SDRAM fixed addresses (128 MB)
   46 00000000         ;;
   47 00000000         ;;    0x80000000 Op code code then data then heap for iM
                       X25
   48 00000000         ;;    various stacks run from top down
   49 00000000         ;;    0xA7FFFFFF top of RAM 
   50 00000000         
   51 00000000         
   52 00000000         ;;
   53 00000000         ;;This is set by assembler build options in the Make fil
                       e 
   54 00000000         ;;
   55 00000000         ;;GBLS    platform_current
   56 00000000         ;platform_current SETS "mxl"  ;;"mxl"
   57 00000000         ;platform_current SETS "imx27"  ;;"imx27"
   58 00000000         ;platform_current SETS "imx25"  ;;"imx25"
   59 00000000         
   60 00000000         ;;
   61 00000000         ;; various sizes 



ARM Macro Assembler    Page 14 


   62 00000000         
   63 00000000 40000000 
                       SZ_1G   EQU              0x40000000
   64 00000000 08000000 
                       SZ_128M EQU              0x08000000
   65 00000000 04000000 
                       SZ_64M  EQU              0x04000000
   66 00000000 02000000 
                       SZ_32M  EQU              0x02000000
   67 00000000 01000000 
                       SZ_16M  EQU              0x01000000
   68 00000000 00800000 
                       SZ_8M   EQU              0x00800000
   69 00000000 00400000 
                       SZ_4M   EQU              0x00400000
   70 00000000 00200000 
                       SZ_2M   EQU              0x00200000
   71 00000000 00100000 
                       SZ_1M   EQU              0x00100000
   72 00000000 00080000 
                       SZ_512K EQU              0x00080000
   73 00000000         
   74 00000000         ;; 2 areas of significant memory blocks are the  externa
                       l SDRAM, and the external Flash ROM
   75 00000000         ;;Configure them by size and platform here
   76 00000000         ;*******************************************************
                       ****************************
   77 00000000                 IF               platform_current = "imx25"
   78 00000000         ;*******************************************************
                       ****************************
   79 00000000         
   80 00000000 80000000 
                       ExternalRamBase
                               EQU              0x80000000  ;; beginning of SDR
                                                            AM, CSD0
   81 00000000 88000000 
                       ExternalRamLimit
                               EQU              0x88000000
   82 00000000 08000000 
                       ExternalRamSize
                               EQU              0x08000000
   83 00000000                 IF               :DEF: CACHEWRITETHRU
   86 00000000 00000C0E 
                       DRAM_ACCESS
                               EQU              0xc0e       ; AP=11, domain0, C
                                                            =B=1
   87 00000000                 ENDIF
   88 00000000 00000C02 
                       NCDRAM_ACCESS
                               EQU              0xc02       ; AP=11, domain0, C
                                                            =B=0
   89 00000000         
   90 00000000         ;; External Flash ROM range
   91 00000000 A0000000 
                       ExternalRomStart
                               EQU              0xA0000000
   92 00000000 A0000000 
                       ExternalRomBase
                               EQU              ExternalRomStart



ARM Macro Assembler    Page 15 


   93 00000000         
   94 00000000         ;; CACHE
   95 00000000 A0000000 
                       CachedExternalRomBase
                               EQU              ExternalRomStart
   96 00000000 00400000 
                       UncachedExternalRomBase
                               EQU              0x00400000
   97 00000000 00100000 
                       ExternalRomSize
                               EQU              0x00100000
   98 00000000 0000080A 
                       FLASH_CACHED_ACCCESS
                               EQU              0x80a       ; AP=10, domain0, c
                                                            =1, b=0
   99 00000000 00000802 
                       FLASH_UNCACHED_ACCCESS
                               EQU              0x802       ; AP=10, domain0, c
                                                            =0, b=0
  100 00000000         
  101 00000000         ;; x25 i/o space, the BASE Address should be aligned to 
                       1M boundaries which are used for the MMU table
  102 00000000         
  103 00000000 00000001 
                       IO1_SIZE
                               EQU              0x1         ; I/O area is actua
                                                            lly 156K in size, b
                                                            ut 1M is the minimu
                                                            m
  104 00000000 00000C02 
                       IO1_ACCESS
                               EQU              0xc02       ; AP=11, domain0, c
                                                            =b=0
  105 00000000 43F00000 
                       IO1_BASE
                               EQU              0x43F00000  ; Mx25 internal reg
                                                            isters and i/o
  106 00000000 00000001 
                       IO2_SIZE
                               EQU              0x1         ;1 Mb 
  107 00000000 00000C02 
                       IO2_ACCESS
                               EQU              0xc02       ; non cache non buf
                                                            fer
  108 00000000 50000000 
                       IO2_BASE
                               EQU              0x50000000  ; Mx25 internal reg
                                                            isters and i/o
  109 00000000 00000001 
                       IO3_SIZE
                               EQU              0x1         ;1 Mb 
  110 00000000 00000C02 
                       IO3_ACCESS
                               EQU              0xc02       ; non cache non buf
                                                            fer
  111 00000000 53F00000 
                       IO3_BASE
                               EQU              0x53F00000  ; Mx25 internal reg
                                                            isters and i/o



ARM Macro Assembler    Page 16 


  112 00000000 00000001 
                       IO4_SIZE
                               EQU              0x1         ;1 Mb 
  113 00000000 00000C02 
                       IO4_ACCESS
                               EQU              0xc02       ; non cache non buf
                                                            fer
  114 00000000 68000000 
                       IO4_BASE
                               EQU              0x68000000  ; Mx25 internal reg
                                                            isters and i/o (asi
                                                            c interrupt control
                                                            ler registers)
  115 00000000 00000001 
                       IO5_SIZE
                               EQU              0x1         ;1 Mb 
  116 00000000 00000C02 
                       IO5_ACCESS
                               EQU              0xc02       ; non cache non buf
                                                            fer
  117 00000000 B8000000 
                       IO5_BASE
                               EQU              0xB8000000  ; Mx25 internal reg
                                                            isters and i/o (sdr
                                                            am controller m3if 
                                                            weim emi)
  118 00000000         
  119 00000000         ;;Vector Table
  120 00000000 00000000 
                       VectorTableVirtualAddress
                               EQU              0x00000000
  121 00000000         
  122 00000000                 IF               :DEF: RAMBASEDBOOT
  127 00000000 80000000 
                       VectorTablePhysicalAddress
                               EQU              ExternalRamBase
  128 00000000                 ENDIF
  129 00000000         
  130 00000000 00000FFE 
                       VECTOR_TABLE_ACCESS
                               EQU              0xffe       ; AP=11, domain0, C
                                                            =B=1
  131 00000000 00000100 
                       VECTOR_TABLE_SIZE
                               EQU              256         ; 256 4K entries
  132 00000000         ;; on chip ram possible location for vectors 45kb  
  133 00000000 00000001 
                       VRAM_NUMSECTIONS
                               EQU              1           ;; use 1 level 1 sc
                                                            tion 
  134 00000000 78000000 
                       VRAM_BASE
                               EQU              0x78000000  ;; start of 1M sect
                                                            ion that vram is in
                                                             vram actually
  135 00000000 00000C0E 
                       VRAM_ACCESS
                               EQU              0xc0e       ;; cachable buffera
                                                            ble 



ARM Macro Assembler    Page 17 


  136 00000000         
  137 00000000         
  138 00000000         ;*******************************************************
                       ****************************
  139 00000000                 ELSE
  253                          ENDIF                        ;;end platform iMX2
                                                            5
  254 00000000         ;*******************************************************
                       ****************************
  255 00000000         
  256 00000000         ;;
  257 00000000         ;; Fixed address space configuration at the top of RAM. 
                        The MMU level 1 translation tables and the cache disabl
                       e buffer
  258 00000000         ;; are at the top of RAM, because their sizes should not
                        be changing.  The stacks are below them, with the syste
                       m mode / user
  259 00000000         ;; mode stack at the bottom, since it is the most likely
                        candidate for growth.
  260 00000000         ;;
  261 00000000 00004000 
                       Level1tabSize
                               EQU              0x4000      ;; MMU level 1 tran
                                                            slation table size 
                                                            is 16K
  262 00000000         
  263 00000000                 IF               :DEF: RAMBASEDBOOT
  266 00000000 87FFC000 
                       Level1tab
                               EQU              ExternalRamLimit - Level1tabSiz
e 
                                                            ;; MMU level 1 tran
                                                            slation table 16K b
                                                            elow top of RAM
  267 00000000                 ENDIF
  268 00000000         
  269 00000000 00001000 
                       Level2VectorTableSize
                               EQU              0x1000      ;; MMU level 2 vect
                                                            or table translatio
                                                            n table size is 4K
  270 00000000 87FFB000 
                       Level2VectorTable
                               EQU              Level1tab - Level2VectorTableSi
ze 
                                                            ;; MMU level 2 vect
                                                            or translation tabl
                                                            e 4K below level 1 
                                                            table
  271 00000000         ;; MMU level 1 translation table
  272 00000000         
  273 00000000         
  274 00000000         
  275 00000000         ;;CORSICA build  ;; used to be CF2D, but this is really 
                       a Corsica change (which includes mxl)
  276 00000000         
  277 00000000         ;; External Ram Model
  278 00000000 00000400 
                       SVC_StackSize



ARM Macro Assembler    Page 18 


                               EQU              1024
  279 00000000 00000400 
                       ABT_StackSize
                               EQU              1024
  280 00000000 00000400 
                       UNDEF_StackSize
                               EQU              1024
  281 00000000 00000400 
                       IRQ_StackSize
                               EQU              1024
  282 00000000 00000400 
                       FIQ_StackSize
                               EQU              1024
  283 00000000         
  284 00000000                 IF               :DEF: RAMBASEDBOOT
  289 00000000 00062000 
                       SYS_StackSize
                               EQU              0x62000
  290 00000000                 ENDIF
  291 00000000         
  292 00000000 87FFB000 
                       Stack_Limit
                               EQU              Level2VectorTable ; give 1K to 
                                                            all stacks and put 
                                                            them at the top of 
                                                            RAM
  293 00000000 87FFB000 
                       SVC_Stack
                               EQU              Stack_Limit
  294 00000000 87FFAC00 
                       ABT_Stack
                               EQU              SVC_Stack-SVC_StackSize
  295 00000000 87FFA800 
                       UNDEF_Stack
                               EQU              ABT_Stack-ABT_StackSize
  296 00000000 87FFA400 
                       IRQ_Stack
                               EQU              UNDEF_Stack-UNDEF_StackSize
  297 00000000 87FFA000 
                       FIQ_Stack
                               EQU              IRQ_Stack-IRQ_StackSize
  298 00000000 87FF9C00 
                       USR_Stack
                               EQU              FIQ_Stack-FIQ_StackSize
  299 00000000 87FF9C00 
                       SYS_Stack
                               EQU              USR_Stack
  300 00000000         
  301 00000000                 IF               :DEF: RAMBASEDBOOT
  305 00000000 87F97C00 
                       Lower_Stack_Limit
                               EQU              USR_Stack-SYS_StackSize ; User 
                                                            / system mode stack
                                                             is ~400K
  306 00000000                 ENDIF
  307 00000000         
  308 00000000 87F97C00 
                       End_Of_Heap
                               EQU              Lower_Stack_Limit



ARM Macro Assembler    Page 19 


  309 00000000         
  310 00000000         ;;END CORSICA
  311 00000000         
  312 00000000         
  313 00000000         
  314 00000000 00000000 
                       ROMStartBootCode
                               EQU              0x0
  315 00000000         
  316 00000000 80001000 
                       RAMStartOpCode
                               EQU              ExternalRamBase +0x1000
  317 00000000         
  318 00000000         
  319 00000000                 INCLUDE          db_sharedtable_h.s ;; this will
                                                             integrate the asso
                                                            ciative shared boot
                                                            /app table into all
                                                             places it is neces
                                                            sary
    1 00000000         ;/******************************************************
                       ******************/
    2 00000000         ;//
    3 00000000         ;// HHP 4480 embedded firmware
    4 00000000         ;//
    5 00000000         ;//  Shared table structure for info shared between boot
                        and assembly code
    6 00000000         ;**** Note this is the assembly version and there is a C
                        equivalent
    7 00000000         ;**** For now, the assumption is he/she who enters here,
                        must also enter there and visa versa
    8 00000000         ;//  Date:       2/24/02
    9 00000000         ;//  Tools:      ARM SDT 2.5 for starters... will be ARM
                        ADS 1.1 or Metaware
   10 00000000         ;//  Target:     D-ball 4480
   11 00000000         ;//
   12 00000000         ;//=====================================================
                       =================================
   13 00000000         ;//   Revision information
   14 00000000         ;//=====================================================
                       =================================
   15 00000000         ;// $RCSfile: db_shared/db_sharedtable_h.s $
   16 00000000         ;// $Revision: 1.12.2.5 $
   17 00000000         ;// $Date: 2009/03/10 11:49:29EDT $
   18 00000000         ;//=====================================================
                       =================================
   19 00000000         ;/******************************************************
                       ******************/
   20 00000000         ;/*|====================================================
                       ===================
   21 00000000         ;  |           MODIFICATION HISTORY
   22 00000000         ;  |====================================================
                       ===================
   23 00000000         ;*******************************************************
                       ******************/
   24 00000000         
   25 00000000         ;; This is the assembly equivalent for the C header for 
                       the same purpose
   26 00000000         ;; Some time was spent imagining a slick way to only hav



ARM Macro Assembler    Page 20 


                       e to change one of these files, but with the changing la
                       ndscape toolswise
   27 00000000         ;; I didn't want to do something that was tool specific.
                         For this reason, any time things are added to the tabl
                       e, it should be added
   28 00000000         ;; in 2 places... here and in db_sharedtable.h
   29 00000000         
   30 00000000         ;;// So to define the memory area definitely
   31 00000000         
   32 00000000                 IF               :DEF: RAMBASEDBOOT
   36 00000000 80000C00 
                       ACTUAL_TABLE_LOCATION_S
                               EQU              RAMStartOpCode - 0x400
   37 00000000         
   38 00000000                 ENDIF
   39 00000000         
   40 00000000         ;; Actual Shared Structure/Table -- Again NOTE, if you a
                       dd here, please add equivalent entry into the db_sharedt
                       able.h C header
   41 00000000 80000C00 
                       SIZE_OF_SHARED_TABLE_S
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x0 ;
                                                            ; how big the table
                                                             is
   42 00000000 80000C04 
                       BOOT_CODE_MINOR_VERSION_S
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x4 ;
                                                            ; Boot code version
                                                             (minor)
   43 00000000 80000C08 
                       BOOT_CODE_MAJOR_VERSION_S
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x8 ;
                                                            ; Boot code version
                                                             (minor)
   44 00000000 80000C0C 
                       SIZE_OF_OP_CODE_TO_STORE_S
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xc ;
                                                            ; means for boot co
                                                            de to inform app to
                                                             *consider* storing
                                                             itself to flash
   45 00000000 80000C10 
                       SIZE_OF_SDRAM_S
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x10 
                                                            ;; means to inform 
                                                            app of size of RAM
   46 00000000         
   47 00000000         ;; Boot code sets DYNAMIC_MEMORY_MAP to 0x12345678 to in
                       dicate that the boot code has configured the dynamic mem
                       ory map variables that follow after.
   48 00000000         ;; Since application code is looking for this value, but
                        may be running on a unit with older boot code that does
                       n't load this value,
   49 00000000         ;; INVERSE_DYNAMIC_MEMORY_MAP is loaded with the 1s comp
                       lement of DYNAMIC_MEMORY_MAP.  The application can compa
                       re DYNAMIC_MEMORY_MAP to the
   50 00000000         ;; inverse of INVERSE_DYNAMIC_MEMORY_MAP and if they don
                       't match, it knows that DYNAMIC_MEMORY_MAP is not valid 
                       and that it will have to default to



ARM Macro Assembler    Page 21 


   51 00000000         ;; an 8MB RAM space memory map.
   52 00000000 80000C14 
                       DYNAMIC_MEMORY_MAP
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x14
   53 00000000 80000C18 
                       INVERSE_DYNAMIC_MEMORY_MAP
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x18
   54 00000000         
   55 00000000 80000C1C 
                       CACHED_MEMORY_BASE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x1C 
                                                            ;; Address of cache
                                                            d memory space, whi
                                                            ch is a
   56 00000000         ;; mirror of non-cached space, but allows cached /
   57 00000000         ;; buffered access to memory.
   58 00000000 80000C20 
                       MEMORY_SIZE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x20 
                                                            ;; Size of detected
                                                             memory in bytes.
   59 00000000         
   60 00000000 80000C24 
                       HEAP_START
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x24 
                                                            ;; Start location o
                                                            f the application h
                                                            eap
   61 00000000 80000C28 
                       HEAP_END
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x28 
                                                            ;; End location of 
                                                            the application hea
                                                            p
   62 00000000 80000C2C 
                       APP_IMAGE_RO_BASE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x2C 
                                                            ;; Start of read on
                                                            ly space in applica
                                                            tion image
   63 00000000 80000C30 
                       APP_IMAGE_RO_END
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x30 
                                                            ;; End of read only
                                                             space in applicati
                                                            on image
   64 00000000 80000C34 
                       APP_IMAGE_RW_BASE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x34 
                                                            ;; Start of read / 
                                                            write space in appl
                                                            ication image
   65 00000000 80000C38 
                       APP_IMAGE_RW_END
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x38 
                                                            ;; End of read / wr
                                                            ite space in applic
                                                            ation image
   66 00000000 80000C3C 



ARM Macro Assembler    Page 22 


                       APP_IMAGE_ZI_BASE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x3C 
                                                            ;; Start of zero in
                                                            it space in applica
                                                            tion image
   67 00000000 80000C40 
                       APP_IMAGE_ZI_END
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x40 
                                                            ;; End of zero init
                                                             space in applicati
                                                            on image
   68 00000000 80000C44 
                       BOOT_CODE_VERSION_STRING_S
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x44 
                                                            ;; Boot code versio
                                                            n string location.
   69 00000000 80000C48 
                       COMPRESSED_APPLICATION_LOCATION
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x48 
                                                            ;;
   70 00000000 80000C4C 
                       COMPRESSED_APPLICATION_SIZE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x4C 
                                                            ;;
   71 00000000 80000C50 
                       APPLICATION_COMPRESSOR_LOCATION
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x50 
                                                            ;;
   72 00000000 80000C54 
                       COMPRESSOR_AND_COMPRESSED_APPLICATION_SIZE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x54 
                                                            ;;
   73 00000000         
   74 00000000         ;; Boot code sets FLASH_DISK_LOCATION to the address whe
                       re it found a flash disk header with a valid application
                        to load.  If none is found, this value
   75 00000000         ;; should be 0xFFFFFFFF.  Since application code is look
                       ing for this value, but may be running on a unit with ol
                       der boot code that doesn't load this
   76 00000000         ;; value, INVERSE_FLASH_DISK_LOCATION is loaded with the
                        1s complement of FLASH_DISK_LOCATION.  The application 
                       can compare FLASH_DISK_LOCATION to the
   77 00000000         ;; inverse of INVERSE_FLASH_DISK_LOCATION and if they do
                       n't match, it knows that FLASH_DISK_LOCATION is not vali
                       d and that it will have to find the
   78 00000000         ;; flash disk itself.
   79 00000000 80000C58 
                       FLASH_DISK_LOCATION
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x58 
                                                            ;;
   80 00000000 80000C5C 
                       INVERSE_FLASH_DISK_LOCATION
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x5C 
                                                            ;;
   81 00000000         
   82 00000000         ;; Boot code startup times that application may want acc
                       ess to for reporting purposes.
   83 00000000 80000C60 
                       BOOT_MAIN_ENTRY_TIME



ARM Macro Assembler    Page 23 


                               EQU              ACTUAL_TABLE_LOCATION_S + 0x60 
                                                            ;;
   84 00000000 80000C64 
                       BOOT_HARDWARE_SETUP_TIME
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x64 
                                                            ;;
   85 00000000 80000C68 
                       BOOT_MEMORY_CHECK_TIME
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x68 
                                                            ;;
   86 00000000 80000C6C 
                       BOOT_ENTRY_POINT_INFORMATION_VALIDATION_TIME
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x6C 
                                                            ;;
   87 00000000 80000C70 
                       BOOT_APPLICATION_COPY_TIME
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x70 
                                                            ;;
   88 00000000 80000C74 
                       BOOT_CHECKSUM_VALIDATION_TIME
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x74 
                                                            ;;
   89 00000000 80000C78 
                       BOOT_CRC_VALIDATION_TIME
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x78 
                                                            ;;
   90 00000000 80000C7C 
                       BOOT_TOTAL_APPLICATION_CODE_LOAD_TIME
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x7c 
                                                            ;;
   91 00000000         
   92 00000000 80000C80 
                       COMPRESSOR_SIZE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x80 
                                                            ;;
   93 00000000 80000C84 
                       COMPRESSED_APPLICATION_HEADER_SIZE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x84 
                                                            ;;
   94 00000000         
   95 00000000 80000C88 
                       NON_CACHED_MEMORY_BASE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x88 
                                                            ;; Address of non-c
                                                            ached memory space,
                                                             which is a
   96 00000000         ;; mirror of cached space, but allows non-cached /
   97 00000000         ;; non-buffered access to memory.
   98 00000000         
   99 00000000 80000C8C 
                       CACHED_ROM_BASE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x8C 
                                                            ;; Address of cache
                                                            d ROM space, which 
                                                            is a
  100 00000000         ;; mirror of non-cached space, but allows cached
  101 00000000         ;; access to memory for speedier read operations.
  102 00000000 80000C90 
                       NON_CACHED_ROM_BASE



ARM Macro Assembler    Page 24 


                               EQU              ACTUAL_TABLE_LOCATION_S + 0x90 
                                                            ;; Address of non-c
                                                            ached ROM space, wh
                                                            ich is a
  103 00000000         ;; mirror of cached space, but allows non-cached /
  104 00000000         ;; non-buffered access to ROM.
  105 00000000 80000C94 
                       ROM_SIZE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x94 
                                                            ;; Size of detected
                                                             ROM in bytes.
  106 00000000 80000C98 
                       MMU_LEVEL_1_TABLE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x98 
                                                            ;; Address of MMU l
                                                            evel 1 translation 
                                                            table.
  107 00000000 80000C9C 
                       MMU_LEVEL_1_TABLE_SIZE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0x9C 
                                                            ;; Size of MMU leve
                                                            l 1 translation tab
                                                            le.
  108 00000000 80000CA0 
                       MMU_LEVEL_2_TABLE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xA0 
                                                            ;; Address of MMU l
                                                            evel 2 vector table
                                                            .
  109 00000000 80000CA4 
                       MMU_LEVEL_2_TABLE_SIZE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xA4 
                                                            ;; Size of MMU leve
                                                            l 2 vector table.
  110 00000000 80000CA8 
                       NOT_USED1
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xA8 
                                                            ;; Address of MMU c
                                                            ache disable buffer
                                                             (no longer
  111 00000000         ;; needed, but removing it now will cause boot /
  112 00000000         ;; application code compatibility problems).
  113 00000000 80000CAC 
                       NOT_USED2
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xAC 
                                                            ;; Size of MMU cach
                                                            e disable buffer (n
                                                            o longer
  114 00000000         ;; needed, but removing it now will cause boot /
  115 00000000         ;; application code compatibility problems).
  116 00000000 80000CB0 
                       SVC_STACK
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xB0 
                                                            ;; Address of SVC s
                                                            tack top.
  117 00000000 80000CB4 
                       ABT_STACK
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xB4 
                                                            ;; Address of ABT s



ARM Macro Assembler    Page 25 


                                                            tack base.
  118 00000000 80000CB8 
                       UNDEF_STACK
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xB8 
                                                            ;; Address of UNDEF
                                                             stack base.
  119 00000000 80000CBC 
                       IRQ_STACK
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xBC 
                                                            ;; Address of IQR s
                                                            tack base.
  120 00000000 80000CC0 
                       FIQ_STACK
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xC0 
                                                            ;; Address of FIQ s
                                                            tack base.
  121 00000000 80000CC4 
                       SYS_STACK
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xC4 
                                                            ;; Address of SYS s
                                                            tack base.
  122 00000000         
  123 00000000 80000CC8 
                       BOOT_TO_APP_REQUEST
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xC8 
                                                            ;; Reserved space t
                                                            o pass a request fr
                                                            om boot to app.
  124 00000000         
  125 00000000 80000CCC 
                       DCMP_HEAP_START
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xCC
  126 00000000 80000CD0 
                       DCMP_HEAP_END
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xD0
  127 00000000 80000CD4 
                       DCMP_APP_IMAGE_RO_BASE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xD4
  128 00000000 80000CD8 
                       DCMP_APP_IMAGE_RO_END
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xD8
  129 00000000 80000CDC 
                       DCMP_APP_IMAGE_RW_BASE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xDC
  130 00000000 80000CE0 
                       DCMP_APP_IMAGE_RW_END
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xE0
  131 00000000 80000CE4 
                       DCMP_APP_IMAGE_ZI_BASE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xE4
  132 00000000 80000CE8 
                       DCMP_APP_IMAGE_ZI_END
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xE8
  133 00000000         
  134 00000000 80000CEC 
                       SHARED_TABLE_FLASHTYPE
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xEC 
                                                            ;; flash type
  135 00000000 80000CF0 



ARM Macro Assembler    Page 26 


                       DEVICE_TYPE_ST
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xF0 
                                                            ;; device type
  136 00000000         
  137 00000000 80000CF0 
                       SHARED_TABLE_LAST_ENTRY_S
                               EQU              ACTUAL_TABLE_LOCATION_S + 0xF0 
                                                            ;; primitive copy o
                                                            f end of struct/tab
                                                            le
  138 00000000         
  139 00000000                 END
  320 00000000         
  321 00000000         
  322 00000000                 END
   35 00000000         
   36 00000000                 REQUIRE8
   37 00000000                 PRESERVE8
   38 00000000         
   39 00000000                 IF               {CPU}="ARM926EJ-S"
   40 00000000         ;; cache specifics arm926EJS
   41 00000000 0000000E 
                       LG2_CSIZE
                               equ              14          ;; log 2 of cache s
                                                            ize in bytes 14= 16
                                                            kb
   42 00000000 00000005 
                       LG2_LSIZE
                               equ              5           ;; log 2 of line si
                                                            ze in bytes 5= 32 b
                                                            ytes
   43 00000000 00000002 
                       LG2_NWAY
                               equ              2           ;; 920 is 64 way 92
                                                            6 is 4 way
   44 00000000 00000005 
                       SET_SHFT
                               equ              5           ;; number of bits t
                                                            o shift to get to l
                                                            sb of set index
   45 00000000 00000007 
                       LG2_SSIZE
                               equ              (LG2_CSIZE-LG2_LSIZE-LG2_NWAY) 
                                                            ;; lo2 of set size
   46 00000000 0000001E 
                       WAY_SHIFT
                               equ              (32-LG2_NWAY)
   47 00000000         
   48 00000000                 ELSE
   56                          ENDIF
   57 00000000         
   58 00000000                 AREA             MMU_mvectorss,CODE, READONLY
   59 00000000                 EXTERN           Vector_Init_Block[WEAK]
   60 00000000                 EXPORT           Move_Vector_Table_To_Zero
   61 00000000         
   62 00000000         ;;Move_Vector_Table_To_Zero-----------------------------
                       -------
   63 00000000         ;; use there example, but avoid using r9 as it may be us
                       ed for relocateability



ARM Macro Assembler    Page 27 


   64 00000000         ;; move vector table from some other location to virtual
                        location 0x0
   65 00000000         ;; this will essentially move the vector table (8 words)
                        and the associative pointers (8 words immediately follo
                       wing) that are used
   66 00000000         ;;
   67 00000000         Move_Vector_Table_To_Zero
   68 00000000 E92D47FF        stmfd            sp!,{r0-r10,lr}
   69 00000004 E3A0A102        ldr              r10,=VectorTablePhysicalAddress
 
                                                            ;; destination
   70 00000008 E59FE010        ldr              r14,=Vector_Init_Block 
                                                            ;; source
   71 0000000C E8BE00FF        ldmia            r14!,{r0-r7} ;; Copy vectors
   72 00000010 E8AA00FF        stmia            r10!,{r0-r7}
   73 00000014 E8BE00FF        ldmia            r14!,{r0-r7} ;; Copy and associ
                                                            ative pointers
   74 00000018 E8AA00FF        stmia            r10!,{r0-r7}
   75 0000001C E8BD87FF        ldmfd            sp!,{r0-r10,pc}
   76 00000020         
   77 00000020         
   78 00000020         
   79 00000020         
   80 00000020 00000000        AREA             MMU_code,CODE, READONLY
   81 00000000         
   82 00000000                 EXPORT           MMU_init
   83 00000000                 EXPORT           MMU_reset
   84 00000000                 EXPORT           MMU_CleanAndInvalidate
   85 00000000                 EXPORT           RelocateAndRun
   86 00000000         
   87 00000000         ;;;;
   88 00000000         ;
   89 00000000         ; Please note:
   90 00000000         ;
   91 00000000         ; --> Dcache w/out write buffer is not allowed
   92 00000000         ; --> Base register updated before tables ASSUMES MMU is
                        off
   93 00000000         ; --> MMU enabled with SR bits 00 --> AP bits govern acc
                       ess
   94 00000000         ; --> Page tables must be aligned to their size
   95 00000000         ;  level1 tables occupy 16KB
   96 00000000         
   97 00000000         ;
   98 00000000         ; 1st thing I need to do is write the translation base r
                       egister
   99 00000000         ; set the domain reg: domain0 CLIENT, domain 1-15 NO_ACC
                       ESS
  100 00000000         ;
  101 00000000         ; **** Here's where the assumption may hurt... reassigni
                       ng the base
  102 00000000         ; register before the TTB are set up assumes MMU off
  103 00000000         ;   but I said that above... so I am sure you were liste
                       ning.
  104 00000000         ; ****
  105 00000000         ;
  106 00000000         ; set up page tables -- all for domain0, flat address ma
                       p
  107 00000000         ;   4x1MB sections for DRAM  -- Read/write all
  108 00000000         ;        -- cacheable, bufferable



ARM Macro Assembler    Page 28 


  109 00000000         ;   1MB section for Flash -- Read/write spvr, Read only 
                       user
  110 00000000         ;       -- cacheable, bufferable
  111 00000000         ;    -- note... for now, I will probably leave this alon
                       e entirely
  112 00000000         ;
  113 00000000         ;  ** Special section ** reserved for clean loops
  114 00000000         ;   **** dedicated VA space for faster access
  115 00000000         ;   **** mapped to SSRAM for fastest access ... can't do
                        in my system because no SRAM
  116 00000000         ;  **** exeption to flat map translation rule
  117 00000000         ; no access for aliased DRAM, Flash
  118 00000000         ;  I/O map enabled noncacheable, nonbufferable incl alia
                       ses
  119 00000000         ;
  120 00000000         ;
  121 00000000         
  122 00000000         ; Flush ITB and DTBs
  123 00000000         ; Flush Icache
  124 00000000         ; Enable MMU, alignment faulting, and conditionally the 
                       Icache, Dcache, and Write buffer
  125 00000000         
  126 00000000         ;;
  127 00000000         ; reminder... goal here is to keep everything 1 to 1... 
                       otherwise my brain will really start
  128 00000000         ; to hurt
  129 00000000         ;;------------------------------------------------------
                       -----------------------------------
  130 00000000         
  131 00000000         
  132 00000000         
  133 00000000         MMU_init
  134 00000000 E92D4008        stmfd            sp!,{r3,lr}
  135 00000004 E59F017C        ldr              r0, =MMU_LEVEL_1_TABLE
  136 00000008 E590E000        ldr              r14,[r0]    ; Use r14 to hold t
                                                            he level 1 table ad
                                                            dress
  137 0000000C                 WRCP15_TTBase    r14         ; initialize TTBR
  151 0000000C EE02EF10        MCR              p15, 0, r14 , c2, c0 ,0
  152 00000010         
  138 00000010 E3A00001        ldr              r0, =1
  139 00000014                 WRCP15_DAControl r0          ; initialize Domain
                                                             access register fo
                                                            r 1 useable domain
  167 00000014 EE030F10        MCR              p15, 0, r0, c3, c0 ,0
  168 00000018         
  140 00000018         ; 1st things 1st... Clear all TT entries -- FAULT
  141 00000018 E3A00000        ldr              r0, =0      ; clear r0 this is 
                                                            what we write to ta
                                                            ble 0 is fault
  142 0000001C E1A0100E        mov              r1, r14     ; r1 has start of l
                                                            evel 1 table
  143 00000020 E3A03A01        ldr              r3, =L1_TABLE_ENTRIES ; r3 has 
                                                            number of level 1 e
                                                            nties used to loop 
                                                            to fill table
  144 00000024         TTclrloop
  145 00000024 E4810004        str              r0, [r1], #4 ; clear 32 bit ent
                                                            ry



ARM Macro Assembler    Page 29 


  146 00000028 E2533001        subs             r3,r3,#1    ; decrement number 
                                                            of entries to go
  147 0000002C 1AFFFFFC        bne              TTclrloop   ; loop until done
  148 00000030         
  149 00000030         ;;
  150 00000030         ; DRAM configuration
  151 00000030         ; Configure according to parameters in shared table.
  152 00000030         ;
  153 00000030 E59F0154        ldr              r0, =CACHED_MEMORY_BASE
  154 00000034 E5901000        ldr              r1,[r0]
  155 00000038 E59F0150        ldr              r0, =MEMORY_SIZE
  156 0000003C E5902000        ldr              r2,[r0]
  157 00000040 E08E1921        add              r1,r14,r1, lsr #18 ; Shift righ
                                                            t by 256K to get of
                                                            fset
  158 00000044 E59F0148        ldr              r0,=DRAM_ACCESS+ExternalRamBase
 
                                                            ; This is the physi
                                                            cal address we want
                                                             to map to
  159 00000048         Dramloop
  160 00000048 E4810004        str              r0, [r1], #4 ; store level 1 TT
                                                             entry
  161 0000004C E2800601        add              r0, r0, #0x00100000 ; keep doin
                                                            g for amount of 1MB
                                                             sections
  162 00000050 E2522601        subs             r2, r2,#0x00100000
  163 00000054 1AFFFFFB        bne              Dramloop
  164 00000058         ;; non cached mapping of dram
  165 00000058 E59F0138        ldr              r0, =NON_CACHED_MEMORY_BASE
  166 0000005C E5901000        ldr              r1,[r0]
  167 00000060 E59F0128        ldr              r0, =MEMORY_SIZE
  168 00000064 E5902000        ldr              r2,[r0]
  169 00000068 E08E1921        add              r1,r14,r1, lsr #18 ; Shift righ
                                                            t by 256K to get of
                                                            fset
  170 0000006C E59F0128        ldr              r0,=NCDRAM_ACCESS+ExternalRamBa
se 
                                                            ; This is the physi
                                                            cal address we want
                                                             to map to
  171 00000070         NCDramloop
  172 00000070 E4810004        str              r0, [r1], #4 ; store level 1 TT
                                                             entry
  173 00000074 E2800601        add              r0, r0, #0x00100000 ; keep doin
                                                            g for amount of 1MB
                                                             sections
  174 00000078 E2522601        subs             r2, r2,#0x00100000
  175 0000007C 1AFFFFFB        bne              NCDramloop
  176 00000080                 IF               (platform_current = "mxl") ;; m
                                                            xl targets have nor
                                                             flash othes do not
                                                            
  205                          ENDIF                        ;; mxl targets with
                                                             nor flash
  206 00000080         IO_SPACE_START
  207 00000080 E28F0080        adr              r0,IO_MAP_TABLE
  208 00000084         IO_SPACE
  209 00000084         ; I/O configuration area



ARM Macro Assembler    Page 30 


  210 00000084         ; 1M of internal registers, non cacheable, non bufferabl
                       e
  211 00000084 E4902004        ldr              r2, [r0],#4 ; r2 is # of 1M blo
                                                            cks
  212 00000088 E3720001        cmp              r2,#-1      ; if -1 this is the
                                                             end of table (IO_M
                                                            AP_TABLE) we are do
                                                            ne
  213 0000008C 0A000007        beq              IO_END
  214 00000090 E4901004        ldr              r1, [r0],#4 ; shifted Phys add 
                                                            of 1M block (offset
                                                             into Lev 1 table)
  215 00000094 E4903004        ldr              r3, [r0],#4 ; get section descr
                                                            iptor info (virt ad
                                                            d+ access)
  216 00000098 E081100E        add              r1,r1,r14
  217 0000009C         IO_loop
  218 0000009C E2522001        subs             r2,r2,#1    ; decr number of se
                                                            ctions 0 in table b
                                                            elow  skips enty
  219 000000A0 4AFFFFF7        bmi              IO_SPACE    ; next table entry 
                                                            (IO_MAP_TABLE)
  220 000000A4 E4813004        str              r3, [r1], #4 ; store TT entry
  221 000000A8 E2833601        add              r3, r3,#(1<<20) 
                                                            ; add section field
                                                            
  222 000000AC EAFFFFFA        b                IO_loop
  223 000000B0         IO_END
  224 000000B0         ; Now that we've set up everything else, let's remap the
                        virtual vector address to the physical vector location.
                       
  225 000000B0 E3A01000        ldr              r1, =(VectorTableVirtualAddress
:SHR:(20-2)) 
                                                            ;Load the level 1 t
                                                            able entry for the 
                                                            level 2 vector tabl
                                                            e
  226 000000B4 E081100E        add              r1,r1,r14   ;r1= address  of ve
                                                            ctor table entry in
                                                             L1 table
  227 000000B8 E59F00E0        ldr              r0, =MMU_LEVEL_2_TABLE
  228 000000BC E5902000        ldr              r2,[r0]     ;Use r2 to hold the
                                                             level 2 table addr
                                                            ess
  229 000000C0 E2822001        add              r2,r2,#1    ;Note that bit 1 mu
                                                            st be 0 and bit 0 m
                                                            ust be 1.
  230 000000C4 E5812000        str              r2, [r1]    ;;store TT entry
  231 000000C8 E2422001        sub              r2,r2,#1    ; address of L2 tab
                                                            le again
  232 000000CC E3A0300E        ldr              r3,=(VECTOR_TABLE_ACCESS:AND:0x
0f) 
                                                            ; AP3-AP0 read only
                                                            , cached, buffered,
                                                             small page referen
                                                            ce
  233 000000D0 E2833102        add              r3,r3,#VectorTablePhysicalAddre
ss 
                                                            ;; this is 0x800000



ARM Macro Assembler    Page 31 


                                                            0 i.e beginning of 
                                                            ram for gen 6 0xa00
                                                            00000
  234 000000D4 E3A00C01        ldr              r0,=VECTOR_TABLE_SIZE ;R3 conta
                                                            ins the physical ad
                                                            dress + the page co
                                                            nfiguration informa
                                                            tion
  235 000000D8         ;; r0 contains number of enties (256 for large page)
  236 000000D8         VectorTableLoop
  237 000000D8 E4823004        str              r3,[r2],#4  ;Load the page conf
                                                            iguration.
  238 000000DC E3A03000        mov              r3,#0       ;; all entries exce
                                                            pt first no accsess
                                                            
  239 000000E0 E2500001        subs             r0,r0,#1
  240 000000E4 1AFFFFFB        bne              VectorTableLoop
  241 000000E8         ;; flush TLBs flush Icache
  242 000000E8 E3A00000        ldr              r0,=0
  243 000000EC EE070F17        mcr              p15,0,r0,c7,c7,0 ;; flush both 
                                                            caches
  244 000000F0                 WRCP15_FlushITB_DTB
                                                r0          ; flush ITB and DTB
                                                            
  271 000000F0 EE080F17        MCR              p15, 0, r0, c8, c7 ,0
  272 000000F4         
  245 000000F4                 RDCP15_Control   r0
  127 000000F4 EE110F10        MRC              p15, 0, r0, c1, c0 ,0
  128 000000F8         
  246 000000F8 E59F10A4        ldr              r1, =EnableMMU+EnableDcache+Ena
bleIcache+EnableMMU_R+EnableAlignFault+EnableMMU_RR
  247 000000FC E1800001        orr              r0,r0,r1
  248 00000100                 WRCP15_Control   r0          ; TURN ON MMU
  135 00000100 EE010F10        MCR              p15, 0, r0, c1, c0 ,0
  136 00000104         
  249 00000104 E8BD8008        ldmia            sp!,{r3,pc} ; return from whenc
                                                            e I came...
  250 00000108         
  251 00000108         
  252 00000108         IO_MAP_TABLE
  253 00000108 00000001        DCD              IO1_SIZE    ; # of 1M blocks
  254 0000010C 000010FC        DCD              (IO1_BASE:SHR:(20-2)) ;shifted 
                                                            virtual address of 
                                                            first 1M section
  255 00000110 43F00C02        DCD              IO1_BASE+IO1_ACCESS ;Phys addr 
                                                            and accsess permiti
                                                            ons S+R+C+B
  256 00000114 00000001        DCD              IO2_SIZE    ; # of 1M blocks
  257 00000118 00001400        DCD              (IO2_BASE:SHR:(20-2)) ;shifted 
                                                            virtual address of 
                                                            first 1M section
  258 0000011C 50000C02        DCD              IO2_BASE+IO2_ACCESS ;Phys addr 
                                                            and accsess permiti
                                                            ons S+R+C+B
  259 00000120 00000001        DCD              IO3_SIZE    ; # of 1M blocks
  260 00000124 000014FC        DCD              (IO3_BASE:SHR:(20-2)) ;shifted 
                                                            virtual address of 
                                                            first 1M section
  261 00000128 53F00C02        DCD              IO3_BASE+IO3_ACCESS ;Phys addr 



ARM Macro Assembler    Page 32 


                                                            and accsess permiti
                                                            ons S+R+C+B
  262 0000012C 00000001        DCD              IO4_SIZE    ; # of 1M blocks
  263 00000130 00001A00        DCD              (IO4_BASE:SHR:(20-2)) ;shifted 
                                                            virtual address of 
                                                            first 1M section
  264 00000134 68000C02        DCD              IO4_BASE+IO4_ACCESS ;Phys addr 
                                                            and accsess permiti
                                                            ons S+R+C+B
  265 00000138 00000001        DCD              IO5_SIZE    ; # of 1M blocks
  266 0000013C 00002E00        DCD              (IO5_BASE:SHR:(20-2)) ;shifted 
                                                            virtual address of 
                                                            first 1M section
  267 00000140 B8000C02        DCD              IO5_BASE+IO5_ACCESS ;Phys addr 
                                                            and accsess permiti
                                                            ons S+R+C+B
  268 00000144         
  269 00000144 00000001        DCD              VRAM_NUMSECTIONS
  270 00000148 00001E00        DCD              (VRAM_BASE:SHR:(20-2)) ;shifted
                                                             virtual address of
                                                             first 1M section
  271 0000014C 78000C0E        DCD              VRAM_BASE+VRAM_ACCESS
  272 00000150 FFFFFFFF        DCD              -1
  273 00000154         
  274 00000154         
  275 00000154         ;
  276 00000154         ;; MMU_reset routine...
  277 00000154         ;; Cleans and flushes d cache
  278 00000154         ;; flushes i cache
  279 00000154         ;; turns cahes and mmu off
  280 00000154         MMU_reset
  281 00000154         ;** For now, don't do a store multiple because of the SD
                       RAM / store multiple problem on MX1.
  282 00000154 E92D4001        stmfd            sp!,{r0,lr}
  283 00000158 EBFFFFFE        bl               MMU_CleanAndInvalidateBothCache
s
  284 0000015C E3A00000        mov              r0,#0
  285 00000160 EE070F9A        mcr              p15,0,r0,c7,c10,4 ;; wait for w
                                                            ite buffer to drain
                                                             before disabling
  286 00000164                 RDCP15_Control   r0
  127 00000164 EE110F10        MRC              p15, 0, r0, c1, c0 ,0
  128 00000168         
  287 00000168 E59FE034        ldr              lr, =EnableMMU+EnableDcache+Ena
bleIcache+EnableMMU_R+EnableAlignFault+EnableMMU_RR
  288 0000016C E1C0000E        bic              r0,r0,lr
  289 00000170                 WRCP15_Control   r0          ;; reset it
  135 00000170 EE010F10        MCR              p15, 0, r0, c1, c0 ,0
  136 00000174         
  290 00000174 E1A00000        nop
  291 00000178 E1A00000        nop
  292 0000017C E1A00000        nop
  293 00000180 E1A00000        nop
  294 00000184 E8BD8001        ldmfd            sp!,{r0,pc}
  295 00000188         
  296 00000188         
  297 00000188 80000C98 
              80000C1C 
              80000C20 



ARM Macro Assembler    Page 33 


              80000C0E 
              80000C88 
              80000C02 
              80000CA0 
              00005207         AREA             MMU_CacheCode,CODE, READONLY
  298 00000000         
  299 00000000         Relocate_Run
  300 00000000         
  301 00000000         
  302 00000000         ; priviledged mode -- SYSTEM mode.  The intent is to nev
                       er run in user mode.
  303 00000000         ;
  304 00000000         
  305 00000000 E321F0DF        msr              cpsr_c,#0xdf ;;Mode_SYS:OR:I_Bi
                                                            t:OR:F_Bit
  306 00000004 E28FE024        adr              r14,st_stack
  307 00000008 E59EE000        ldr              r14,[r14]
  308 0000000C E59ED000        ldr              sp,[r14]
  309 00000010 E1A0E001        mov              lr,r1       ;; start address of
                                                             new ap in lr
  310 00000014 E1510000        cmp              r1,r0
  311 00000018 AA000005        bge              cpyrevstart
  312 0000001C         cpyfwd
  313 0000001C E4903004        ldr              r3,[r0],#4
  314 00000020 E4813004        str              r3,[r1],#4
  315 00000024 E2522004        subs             r2,r2,#4
  316 00000028 1AFFFFFB        bne              cpyfwd
  317 0000002C EAFFFFFE        b                MMU_CleanAndInvalidateBothCache
s
  318 00000030         st_stack
  319 00000030 80000CC4        DCD              SYS_STACK
  320 00000034         cpyrevstart
  321 00000034 E0800002        add              r0,r0,r2
  322 00000038 E0811002        add              r1,r1,r2
  323 0000003C         cpyrev
  324 0000003C E5303004        ldr              r3,[r0,#-4]!
  325 00000040 E5213004        str              r3,[r1,#-4]!
  326 00000044 E2522004        subs             r2,r2,#4
  327 00000048 1AFFFFFB        bne              cpyrev
  328 0000004C         ;; MMU_CleanAndInvalidateBothCaches
  329 0000004C         ;; Cleans and flushes d cache
  330 0000004C         ;; flushes i cache
  331 0000004C         
  332 0000004C                 EXPORT           MMU_CleanAndInvalidateBothCache
s
  333 0000004C         MMU_CleanAndInvalidateBothCaches
  334 0000004C E92D4001        stmfd            sp!,{r0,lr}
  335 00000050 EBFFFFFE        bl               MMU_CleanAndInvalidate
  336 00000054 E3A00000        mov              r0,#0
  337 00000058                 WRCP15_FlushIC   r0
  217 00000058 EE070F15        MCR              p15, 0, r0, c7, c5 ,0
  218 0000005C         
  338 0000005C E8BD8001        ldmfd            sp!,{r0,pc}
  339 00000060         
  340 00000060         
  341 00000060         ;;============ MMU_CleanAndInvalidate ==================
                       ===============
  342 00000060         ;; clean and invalidate d cache
  343 00000060         ;;MXL arm920 uses set/way method



ARM Macro Assembler    Page 34 


  344 00000060         ;;MX27 arm926EJS uses test clean
  345 00000060         ;; irqs should be off
  346 00000060         ;; uses R0
  347 00000060         
  348 00000060                 IF               {CPU}="ARM926EJ-S"
  349 00000060         ;; use test clean
  350 00000060         MMU_CleanAndInvalidate
  351 00000060                 RDCP15_Control   r0
  127 00000060 EE110F10        MRC              p15, 0, r0, c1, c0 ,0
  128 00000064         
  352 00000064 E3100001        tst              r0,#EnableMMU
  353 00000068 0A000001        beq              MMU_CleanAndInvalidate_Finish
  354 0000006C                 IF               :DEF: CACHEWRITETHRU
  360 0000006C         MMU_CleanAndInvalidate_loop
  361 0000006C EE17FF7E        mrc              p15,0,pc,c7,c14,3 ;; for 926 us
                                                            e test clean use of
                                                             pc as shown in arm
                                                             926 TRM
  362 00000070 1AFFFFFD        bne              MMU_CleanAndInvalidate_loop
  363 00000074         MMU_CleanAndInvalidate_Finish
  364 00000074 E12FFF1E        bx               lr
  365 00000078                 ENDIF
  366 00000078                 ELSE
  383                          ENDIF
  384 00000078         Relocate_Run_End
  385 00000078         ;
  386 00000078         ; MMU_IsEnabled
  387 00000078         ;  Return 1 if MMU is enabled, 0 otherwise.
  388 00000078         ;
  389 00000078                 EXPORT           MMU_IsEnabled
  390 00000078         MMU_IsEnabled
  391 00000078                 RDCP15_Control   r0
  127 00000078 EE110F10        MRC              p15, 0, r0, c1, c0 ,0
  128 0000007C         
  392 0000007C E2000001        and              r0,r0,#EnableMMU
  393 00000080 E12FFF1E        bx               lr
  394 00000084         
  395 00000084         ;  void RelocateAndRun(int TRANSFER_ADDRESS, int EXECUTA
                       BLE_RELOCATION_ADDRESS,
  396 00000084         ;          int SizeOfExecutableImage);
  397 00000084         ;
  398 00000084         RelocateAndRun
  399 00000084 E59F3020        ldr              r3,=HEAP_END
  400 00000088 E5933000        ldr              r3,[r3]
  401 0000008C E2834078        add              r4,r3,#(Relocate_Run_End-Reloca
te_Run)
  402 00000090         
  403 00000090 E24F5020        adr              r5,Relocate_Run_End
  404 00000094         copy_mmu
  405 00000094 E5356004        ldr              r6,[r5,#-4]!
  406 00000098 E5246004        str              r6,[r4,#-4]!
  407 0000009C E1530004        cmp              r3,r4
  408 000000A0 1AFFFFFB        bne              copy_mmu
  409 000000A4 EBFFFFFE        bl               MMU_CleanAndInvalidateBothCache
s
  410 000000A8 E12FFF13        bx               r3          ;; jump to where we
                                                             loaded the relocat
                                                            or
  411 000000AC         



ARM Macro Assembler    Page 35 


  412 000000AC         
  413 000000AC         
  414 000000AC         
  415 000000AC 80000C28        AREA             MMU_Cache_ON_OFF,CODE, READONLY
  416 00000000                 EXPORT           DCacheOn
  417 00000000         DCacheOn
  418 00000000                 RDCP15_Control   r0
  127 00000000 EE110F10        MRC              p15, 0, r0, c1, c0 ,0
  128 00000004         
  419 00000004 E3A01004        ldr              r1, =EnableDcache
  420 00000008 E1800001        orr              r0,r0,r1
  421 0000000C                 WRCP15_Control   r0          ; urn on icache
  135 0000000C EE010F10        MCR              p15, 0, r0, c1, c0 ,0
  136 00000010         
  422 00000010 E12FFF1E        bx               lr
  423 00000014         
  424 00000014         
  425 00000014                 EXPORT           DCacheOff
  426 00000014         DCacheOff
  427 00000014 E1A0100E        mov              r1,lr       ;; save link regist
                                                            er call below chang
                                                            es it
  428 00000018 EBFFFFFE        bl               MMU_CleanAndInvalidate ;; flush
                                                             and invalidate cac
                                                            he
  429 0000001C E1A0E001        mov              lr,r1       ;;restore link regi
                                                            ster 
  430 00000020                 RDCP15_Control   r0
  127 00000020 EE110F10        MRC              p15, 0, r0, c1, c0 ,0
  128 00000024         
  431 00000024 E3A01004        ldr              r1, =EnableDcache
  432 00000028 E1C00001        bic              r0,r0,r1
  433 0000002C                 WRCP15_Control   r0          ; urn on icache
  135 0000002C EE010F10        MCR              p15, 0, r0, c1, c0 ,0
  136 00000030         
  434 00000030 E12FFF1E        bx               lr
  435 00000034         
  436 00000034                 EXPORT           ICacheOn
  437 00000034         ICacheOn
  438 00000034                 RDCP15_Control   r0
  127 00000034 EE110F10        MRC              p15, 0, r0, c1, c0 ,0
  128 00000038         
  439 00000038 E3A01A01        ldr              r1, =EnableIcache
  440 0000003C E1800001        orr              r0,r0,r1
  441 00000040                 WRCP15_Control   r0          ; urn on icache
  135 00000040 EE010F10        MCR              p15, 0, r0, c1, c0 ,0
  136 00000044         
  442 00000044 E12FFF1E        bx               lr
  443 00000048         
  444 00000048         
  445 00000048                 EXPORT           ICacheOff
  446 00000048         ICacheOff
  447 00000048 E3A00000        mov              r0,#0
  448 0000004C                 WRCP15_FlushIC   r0
  217 0000004C EE070F15        MCR              p15, 0, r0, c7, c5 ,0
  218 00000050         
  449 00000050                 RDCP15_Control   r0
  127 00000050 EE110F10        MRC              p15, 0, r0, c1, c0 ,0
  128 00000054         



ARM Macro Assembler    Page 36 


  450 00000054 E3A01A01        ldr              r1, =EnableIcache
  451 00000058 E1C00001        bic              r0,r0,r1
  452 0000005C                 WRCP15_Control   r0          ; urn on icache
  135 0000005C EE010F10        MCR              p15, 0, r0, c1, c0 ,0
  136 00000060         
  453 00000060 E12FFF1E        bx               lr
  454 00000064         
  455 00000064         
  456 00000064         ;
  457 00000064         ; ******************************************************
                       ********************************************************
                       ******************
  458 00000064         ;
  459 00000064         ; All code within this IF is unneeded by boot.
  460 00000064         ;
  461 00000064         ; ******************************************************
                       ********************************************************
                       ******************
  462 00000064         ;
  463 00000064                 IF               :DEF: MATRIX_BOOT_CODE
  466 00000064         
  467 00000064         
  468 00000064         
  469 00000064         
  470 00000064                 EXPORT           ICacheLockdown
  471 00000064         ; r0 = pointer to array of addresses of code segments to
                        be locked down
  472 00000064         ; r1 = pointer to array of sizes of code segments to be 
                       locked down
  473 00000064         ; r2 = number of code segments to be locked down
  474 00000064         ICacheLockdown
  475 00000064 E92D5FF8        stmfd            sp!,{r3-r12, lr}
  476 00000068         ; Prepare to jump to non-cache RAM to actually perform t
                       he lockdown, so that no part of this routine is loaded i
                       nto ICache during the
  477 00000068         ; lockdown process.
  478 00000068 E59F6074        ldr              r6,=NON_CACHED_MEMORY_BASE
  479 0000006C E5963000        ldr              r3,[r6]     ; r3 = base address
                                                             of non-cache RAM
  480 00000070 E59F6070        ldr              r6,=CACHED_MEMORY_BASE
  481 00000074 E5964000        ldr              r4,[r6]     ; r4 = base address
                                                             of cache RAM
  482 00000078 E28F5008        adr              r5,ICacheLockdownNonCacheOffset
Jump
  483 0000007C E0455004        sub              r5,r5,r4
  484 00000080 E0855003        add              r5,r5,r3    ; r5 = address of I
                                                            CacheLockdownNonCac
                                                            heOffsetJump in non
                                                            -cache RAM
  485 00000084 E12FFF15        bx               r5
  486 00000088         ICacheLockdownNonCacheOffsetJump
  487 00000088 E3A03000        ldr              r3,=0       ; Lockdown base
  488 0000008C E3A04000        ldr              r4,=0       ; Start with clean 
                                                            ICache
  489 00000090                 WRCP15_FlushIC   r4
  217 00000090 EE074F15        MCR              p15, 0, r4, c7, c5 ,0
  218 00000094         
  490 00000094         ICacheLockdownNextCodeSegmentLoop
  491 00000094 E2522001        subs             r2,r2,#1    ; Keep looping thro



ARM Macro Assembler    Page 37 


                                                            ugh code segments u
                                                            ntil we reach the e
                                                            nd
  492 00000098 BA000010        blt              ICacheLockdownFinish
  493 0000009C E4904004        ldr              r4,[r0],#4  ; r4 = start addres
                                                            s of next code segm
                                                            ent
  494 000000A0 E4915004        ldr              r5,[r1],#4
  495 000000A4 E0855004        add              r5,r5,r4    ; r5 = end address 
                                                            of next code segmen
                                                            t
  496 000000A8 E3C4401F        and              r4,r4,#0xFFFFFFE0 ; Mask start 
                                                            address to a linefi
                                                            ll boundary
  497 000000AC EE093F30        mcr              p15,0,r3,c9,c0,1 ; Lockdown bas
                                                            e index 0
  498 000000B0         ICacheLockdownCodeSegmentLoadLoop
  499 000000B0 EE074F3D        mcr              p15,0,r4,c7,c13,1 ; Prefetch ne
                                                            xt line
  500 000000B4 E2844020        add              r4,r4,#32   ; r4 = next line in
                                                             code segment
  501 000000B8 E20460E0        and              r6,r4,#0xe0 ; Did the segment r
                                                            oll over into a new
                                                             tag?
  502 000000BC E3560000        cmp              r6,#0x0
  503 000000C0 02833301        addeq            r3,r3,#0x1<<26 ; Increment base
                                                             index and lockdown
                                                             if the segment rol
                                                            led over into a new
                                                             tag
  504 000000C4 0E093F30        mcreq            p15,0,r3,c9,c0,1
  505 000000C8 E1540005        cmp              r4,r5       ; Keep looping unti
                                                            l we're done with t
                                                            his segment
  506 000000CC DAFFFFF7        ble              ICacheLockdownCodeSegmentLoadLo
op
  507 000000D0 E3560000        cmp              r6,#0x0     ; If more lines wer
                                                            e added after the l
                                                            ast base index incr
                                                            ement and lockdown,
                                                             then lock
  508 000000D4 12833301        addne            r3,r3,#0x1<<26 ; the additional
                                                             lines
  509 000000D8 1E093F30        mcrne            p15,0,r3,c9,c0,1
  510 000000DC EAFFFFEC        b                ICacheLockdownNextCodeSegmentLo
op
  511 000000E0         ICacheLockdownFinish                 ; Return to caller
  512 000000E0 E8BD9FF8        ldmfd            sp!,{r3-r12, pc}
  513 000000E4         
  514 000000E4         
  515 000000E4 80000C88 
              80000C1C         AREA             MMU_ReadITLB_DTLB,CODE, READONL
Y
  516 00000000         
  517 00000000         
  518 00000000         ;
  519 00000000         ; Return the current value of the instruction TLB regist
                       er to the caller via R0
  520 00000000         ;



ARM Macro Assembler    Page 38 


  521 00000000                 EXPORT           ITLB_Read
  522 00000000         ITLB_Read
  523 00000000 EE1A0F30        mrc              p15,0,r0,c10,c0,1
  524 00000004 E12FFF1E        bx               lr
  525 00000008         
  526 00000008         
  527 00000008         
  528 00000008         
  529 00000008         ;
  530 00000008         ; Return the current value of the data TLB register to t
                       he caller via R0
  531 00000008         ;
  532 00000008                 EXPORT           DTLB_Read
  533 00000008         DTLB_Read
  534 00000008 EE1A0F10        mrc              p15,0,r0,c10,c0,0
  535 0000000C E12FFF1E        bx               lr
  536 00000010         ;
  537 00000010         ; ******************************************************
                       ********************************************************
                       ******************
  538 00000010         ;
  539 00000010         ; All code within this IF is unneeded by boot.
  540 00000010         ;
  541 00000010         ; ******************************************************
                       ********************************************************
                       ******************
  542 00000010         ;
  543 00000010                 ENDIF
  544 00000010                 END
Command Line: --debug --cpu=ARM926EJ-S --fpu=None --apcs=/interwork --depend=Ou
tput_APP_imx25_ID_FF3_3110/db_mmu.d -oOutput_APP_imx25_ID_FF3_3110/db_mmu.o -ID
:\Super2D\source\Gen6FoundationApp/libraries/OsKernel/app_kernel -ID:\Super2D\s
ource\Gen6FoundationApp/libraries/OsKernel/db_shared -ID:\Super2D\source\Gen6Fo
undationApp/libraries/OsKernel/temp_shared -ID:\Super2D\source\Gen6FoundationAp
p/libraries/OsKernel/db_shared/Hardware_Header_Files -ID:\Super2D\source\Gen6Fo
undationApp/libraries/OsKernel/db_shared/Hardware_Header_Files/iMXL -ID:\Super2
D\source\Gen6FoundationApp/libraries/OsKernel/db_shared/Hardware_Header_Files/i
MX27 -ID:\Super2D\source\Gen6FoundationApp/libraries/OsKernel/db_shared/Hardwar
e_Header_Files/iMX25 -ID:\Super2D\source\Gen6FoundationApp/FoundationApp -ID:\S
uper2D\source\Gen6FoundationApp/FoundationApp/Batch_Mode -ID:\Super2D\source\Ge
n6FoundationApp/FoundationApp/Foundation_Temp -ID:\Super2D\source\Gen6Foundatio
nApp/FoundationApp/Imaging -ID:\Super2D\source\Gen6FoundationApp/FoundationApp/
Flash -ID:\Super2D\source\Gen6FoundationApp/FoundationApp/Peripheral_Interfaces
 -ID:\Super2D\source\Gen6FoundationApp/FoundationApp/PageButton -ID:\Super2D\so
urce\Gen6FoundationApp/FoundationApp/Trigger -ID:\Super2D\source\Gen6Foundation
App/FoundationApp/menu -ID:\Super2D\source\Gen6FoundationApp/FoundationApp/eci 
-ID:\Super2D\source\Gen6FoundationApp/FoundationApp/LeanAutomationTest -ID:\Sup
er2D\source\Gen6FoundationApp/FoundationApp/dirt_test -ID:\Super2D\source\Gen6F
oundationApp/FoundationApp/PSOC -ID:\Super2D\source\Gen6FoundationApp/Foundatio
nApp/Plugin -ID:\Super2D\source\Gen6FoundationApp/hhpscandriver -ID:\Super2D\so
urce\Gen6FoundationApp/libraries/stringanddata -ID:\Super2D\source\Gen6Foundati
onApp/libraries/CommandParsers -ID:\Super2D\source\Gen6FoundationApp/libraries/
buffer_fifo_utils -ID:\Super2D\source\Gen6FoundationApp/libraries/Safe_FFS/src/
common -ID:\Super2D\source\Gen6FoundationApp/libraries/Safe_FFS/src/nor -ID:\Su
per2D\source\Gen6FoundationApp/libraries/Safe_FFS/src/nor/phy/Numonyx_winbond -
ID:\Super2D\source\Gen6FoundationApp/libraries/G6_configuration -ID:\Super2D\so
urce\Gen6FoundationApp/libraries/Communication_Gen6 -ID:\Super2D\source\Gen6Fou
ndationApp/libraries/Communication_Gen6/Matrix -ID:\Super2D\source\Gen6Foundati
onApp/libraries/compression -ID:\Super2D\source\Gen6FoundationApp/libraries/sha



ARM Macro Assembler    Page 39 


red_matrix_interfaces/interfaces -ID:\Super2D\source\Gen6FoundationApp/librarie
s/shared_matrix_interfaces/interfaces_hw -ID:\Super2D\source\Gen6FoundationApp/
libraries/shared_matrix_interfaces/interfaces_rf -ID:\Super2D\source\Gen6Founda
tionApp/libraries/shared_matrix_interfaces/interfaces_wedge -ID:\Super2D\source
\Gen6FoundationApp/libraries/shared_matrix_interfaces/interfaces_wedge_hw -ID:\
Super2D\source\Gen6FoundationApp/libraries/shared_matrix_interfaces/customizati
on -ID:\Super2D\source\Gen6FoundationApp/libraries/Cryptography -ID:\Super2D\so
urce\Gen6FoundationApp/libraries/G6_Imaging -ID:\Super2D\source\Gen6FoundationA
pp/libraries/HHPL_Script -ID:\Super2D\source\Gen6FoundationApp/libraries/HHPL_S
cript/Gen6 -ID:\Super2D\source\Gen6FoundationApp/libraries/shared_matrix_interf
aces/interfaces_usb2_hw -ID:\Super2D\source\Gen6FoundationApp/libraries/shared_
matrix_interfaces/interfaces_usb2/base_usb2 -ID:\Super2D\source\Gen6FoundationA
pp/libraries/shared_matrix_interfaces/interfaces_usb2/cdcacm_usb2 -ID:\Super2D\
source\Gen6FoundationApp/libraries/shared_matrix_interfaces/interfaces_usb2/hid
_usb2/hidbase_usb2 -ID:\Super2D\source\Gen6FoundationApp/libraries/shared_matri
x_interfaces/interfaces_usb2/hid_usb2/pos_usb2 -ID:\Super2D\source\Gen6Foundati
onApp/libraries/shared_matrix_interfaces/interfaces_usb2/hid_usb2/surepos_usb2 
-ID:\Super2D\source\Gen6FoundationApp/libraries/shared_matrix_interfaces/interf
aces_usb2/hid_usb2/kbdpc_usb2 -ID:\Super2D\source\Gen6FoundationApp/libraries/s
hared_matrix_interfaces/interfaces_usb2/rem -ID:\Super2D\source\Gen6FoundationA
pp/FoundationApp/mocf -ID:\Super2D\source\Gen6FoundationApp/FoundationApp/mocf/
shared -ID:\Super2D\source\Gen6FoundationApp/FoundationApp/mocf/shared/sha1 -ID
:\Super2D\source\Gen6FoundationApp/libraries/DecoderLib -ID:\Super2D\source\Gen
6FoundationApp/libraries/DecoderLib/Source --predefine="platform_current SETS \
"imx25\"" --predefine="CORDED SETL {TRUE}" --predefine="Board_TARGET SETS \"iMX
25_Development\"" --list=Output_APP_imx25_ID_FF3_3110/db_mmu.lst D:\Super2D\sou
rce\Gen6FoundationApp\libraries\OsKernel\db_shared\db_mmu.s
