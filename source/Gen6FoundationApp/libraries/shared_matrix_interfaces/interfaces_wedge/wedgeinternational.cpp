/*=================================================================================
  	class: CWedgeInternational
	Here we handle the keyboard layout part of the international support.
//=================================================================================
   $Source: interfaces_wedge/wedgeinternational.cpp $
   $Date: 2009/06/29 05:03:31EDT $
   $Revision: 2.1 $



//=================================================================================*/

#include "stdInclude.h"
#include "CommonDriver.h"
#include "WedgeInternational.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CWedgeInternational::CWedgeInternational(CDriverBase *pDriver, const CWedgeTerminal *pTerminal)
:baseCWedgeInternational(pDriver, pTerminal)
{
}

bool CWedgeInternational::IsCountrySupported(const CKeyFixups *pFix, int country)
{
	return ((country >= pFix->m_MinCountry) && (country <= pFix->m_MaxCountry));
}

bool CWedgeInternational::IsCountrySupported(int country)
{
	return IsCountrySupported(m_pTerminal->GetFixups(), country);
}

// Change the "character to key" table for this country.
// This adjusts the translation to varius keyboard layouts.
void CWedgeInternational::DoInternationalExceptions(const CKeyFixup *pExc)
{
	ASSERT(pExc != NULL);
	while(pExc->m_keynum != KN_ENDMARKER)
	{
		m_KeyNumLookup.StoreKey(pExc->m_character, pExc->m_keynum, pExc->m_modifier);
		pExc++;
	}
}


// Call this to enable international support for keyboard layouts.
// The table it uses are generated by a PC program (forkey).
void CWedgeInternational::DoInternationalSupport(const CKeyFixups *pFix, int country)
{
	if (pFix != NULL)		/* Allow for a NULL pointer passed if no support is required */
	{
		assert(pFix->m_pParent != pFix);	      // would be a endless recursion
		if (pFix->m_pParent != pFix)
		{
			if (IsCountrySupported(pFix, country))	// don't bother with unsupported countries (keep US table)
			{
				// if there is a parent, then do this table first
				if	(pFix->m_pParent != NULL)
					DoInternationalSupport(pFix->m_pParent, country);	// call ourself recursivly

				// now do our table
				country -= pFix->m_MinCountry;	      				// remove offset

				// point to table of fixup pointers, one for each country
				const CKeyFixup **pCountries = pFix->m_pCountries;  

				if (pCountries[country] != NULL)
					DoInternationalExceptions(pCountries[country]);
			}
		}
	}
}




